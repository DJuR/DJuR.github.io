---
layout: post
title: "亿级系统架构演进：从1个用户到亿级用户"
date: 2026-02-09
summary: "一篇给 后端 / 架构师 / 技术负责人 的实战型文章"
tags: [笔记, 架构]
published: true
---


> 一篇给 **后端 / 架构师 / 技术负责人** 的实战型文章，讲清楚：
>
> * 系统是**如何一步步演进**的
> * **每个阶段解决什么问题**
> * **什么时候必须升级架构**
> * 亿级系统的**通用底层逻辑**

---

## 一、为什么要“分阶段看架构”？

很多人一上来就问：

> 10 亿用户的系统是怎么设计的？

但真实世界里，没有任何一个系统：

* 第一天就有微服务
* 第一天就有分库分表
* 第一天就上 Kafka + Flink

**正确问题应该是：**

> 从 1 个用户开始，系统在什么节点“被迫进化”？

这篇文章，我们用 **1 → 1 千 → 1 万 → 100 万 → 1 亿用户** 来拆解。

---

## 二、总体“亿级”架构全景图（逻辑视图）

```
┌──────── 用户终端 ────────┐
│ App / Web / 小程序      │
└─────────┬──────────────┘
          │ HTTPS
┌─────────▼──────────────┐
│        CDN / 边缘节点    │  ← 视频、图片、静态资源
└─────────┬──────────────┘
          │
┌─────────▼──────────────┐
│      API Gateway        │  ← 鉴权 / 限流 / 路由
└─────────┬──────────────┘
          │
┌─────────▼──────────────┐
│  业务微服务集群          │
│  - 用户服务              │
│  - 内容服务              │
│  - 推荐服务              │
│  - 互动服务              │
└─────────┬──────────────┘
          │
┌─────────▼──────────────┐
│ 缓存层 Redis / KV        │
└─────────┬──────────────┘
          │
┌─────────▼──────────────┐
│ 数据库层（分库分表）     │
│ MySQL / TiDB / NewSQL   │
└─────────┬──────────────┘
          │
┌─────────▼──────────────┐
│ 消息 & 流处理            │
│ Kafka / Pulsar / Flink  │
└────────────────────────┘
```

**注意**：上面不是“一开始就有”，而是**最终态**。

---

## 三、阶段 1：1～1千 用户（原始形态）

### 架构

```
用户 → Web/App → 单体应用 → 单 MySQL
```

### 技术选择

* 单体应用（Spring Boot / Django / Node）
* 单库 MySQL
* 本地文件存储

### 核心目标

> **验证业务是否成立**

### 典型特征

* 一台服务器
* 所有功能一个进程
* 没缓存、没消息队列

🚨 **千万不要过度设计**

---

## 四、阶段 2：1 千～1 万用户（初步工程化）

### 新问题

* 并发开始上来
* 数据库连接数不够
* 图片加载慢

### 架构变化

```
用户 → CDN → 应用 → MySQL
               ↓
             Redis
```

### 引入组件

* Redis（缓存用户信息）
* CDN（静态资源）
* Nginx

### 核心目的

> **让系统“跑得稳”**

---

## 五、阶段 3：1 万～100 万用户（第一次质变）

### 痛点

* 单体应用发布慢
* 某功能拖垮全站
* 数据库 CPU 飙升

### 架构演进：

```
           ┌─ 用户服务 ─┐
用户 → 网关 ├─ 内容服务 ├→ Redis → MySQL
           └─ 互动服务 ─┘
```

### 关键动作

* 拆 **微服务（按业务域）**
* Redis 成为“必选项”
* 读多写少 → 缓存优先

### 数据库

* **开始分库（按业务）**

  * user_db
  * content_db

---

## 六、阶段 4：100 万～1000 万用户（平台级系统）

### 新问题

* 数据量指数增长
* 热点用户 / 热点视频
* 异步需求爆炸

### 架构升级

```
用户
 ↓
CDN → 网关 → 微服务集群
               ↓
        Redis Cluster
               ↓
     MySQL 分库分表
               ↓
           Kafka
```

### 核心技术

* **分库分表**（user_id hash）
* Kafka 解耦写操作
* 读写分离

### 示例：用户表

```
user_db_00.user_0000
user_db_00.user_0001
...
user_db_15.user_1023
```

---

## 七、阶段 5：1000 万～1 亿用户（准抖音级别）

### 系统特征

* 万级 QPS
* PB 级数据
* 全球访问

### 架构特征

```
全球用户
  ↓
就近 CDN / 边缘计算
  ↓
多 Region 网关
  ↓
微服务 Mesh
  ↓
Redis + KV
  ↓
NewSQL / 分布式存储
  ↓
Kafka → Flink → 推荐系统
```

### 数据层

* MySQL + Sharding
* 部分场景用 KV（用户画像）
* 冷热数据分离

---

## 八、阶段 6：1 亿～10 亿用户（真正的抖音级架构）

### 核心挑战

* 全球多地域访问（跨国、跨洲）
* 峰值 QPS 达到百万级
* 推荐、风控、广告实时决策
* 单点故障 = 全网事故

### 架构形态（逻辑视图）

```
全球用户
 ↓
智能 DNS + Anycast
 ↓
全球 CDN / 边缘计算
 ↓
多 Region API Gateway
 ↓
Service Mesh（服务治理）
 ↓
业务微服务集群（自动弹性）
 ↓
Redis / KV（万亿 Key）
 ↓
NewSQL / 分布式存储
 ↓
Kafka / Pulsar（百万 TPS）
 ↓
Flink / Spark Streaming
 ↓
推荐 / 风控 / 广告系统
```

### 数据层终态

* 用户数据：

  * 多活 NewSQL（TiDB / Spanner 类）
  * 强一致 & 就近访问
* 行为数据：

  * 日志即事实源（Log as Source of Truth）
* 冷热数据：

  * 热数据 KV
  * 冷数据对象存储

### 架构关键词

* 多活多写
* Region 级容灾
* 数据最终一致
* 自动扩缩容

---

## 九、全阶段架构对照表（1 → 10 亿用户）

| 用户规模  | 架构形态  | 核心技术    | 典型触发点  |
| ----- | ----- | ------- | ------ |
| 1-100 | 单体    | 单 MySQL | 验证业务   |
| 1k    | 单体+缓存 | Redis   | DB 慢   |
| 10w   | 微服务   | 网关      | 发布风险   |
| 100w  | 微服务集群 | 分库      | 连接数爆   |
| 1000w | 平台架构  | MQ      | 异步爆发   |
| 1亿    | 分布式系统 | 流计算     | 实时推荐   |
| 10亿   | 全球系统  | 多活      | 全球 SLA |

---

## 十、核心认知总结

| 用户规模  | 架构形态  | 关键技术  | 升级信号  |
| ----- | ----- | ----- | ----- |
| 1-100 | 单体    | MySQL | 验证业务  |
| 1k    | 单体+缓存 | Redis | DB 慢  |
| 10w   | 微服务   | 网关    | 发布慢   |
| 100w  | 微服务集群 | 分库    | DB 压力 |
| 1000w | 平台架构  | Kafka | 异步爆炸  |
| 1亿    | 分布式系统 | Flink | 数据驱动  |

---

## 九、核心认知总结

> **抖音不是设计出来的，是被用户“打”出来的。**

* 架构升级 ≠ 炫技
* 架构升级 = 被性能、规模、稳定性逼的
* 80% 系统永远到不了 100 万用户

---
